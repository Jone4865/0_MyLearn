Array는 연속적인 메모리 위치에 요소를 저장하므로 
저장된 요소에 대한 주소를 쉽게 계산할 수 있으며 
이를 통해 특정 인덱스의 요소에 더 빠르게 액세스할 수 있습니다.

LinkedList는 저장 구조가 덜 엄격하고 요소는 일반적으로 인접한 위치에 저장되지 않으므로 
다음 요소에 대한 참조를 제공하는 추가 태그와 함께 저장해야 합니다.

Array(배열)
- 논리적 저장순서와 물리적 저장 순서가 일치한다.
- 인덱스로 해당 원소에 접근이 가능하다.
- 인덱스만 알고 있다면 시간 복잡도 O(1)만에 해당 원소로 접근할 수 있다.
- 즉, Random Access가 가능하다.
- 배열의 원소를 삭제할 경우 삭제한 원소보다 큰 인덱스를 가진 원소들을 옮겨줘야(Shift) 하기 때문에 시간 복잡도 O(n)이 걸린다.
- 삽입의 경우, 새로운 원소를 추가하고 모든 원소들의 인덱스를 1씩 Shift 해줘야 하므로 시간 복잡도 O(n)이 걸린다.
- 제한적인 크기를 갖는다.
즉, 삭제 또는 삽입 과정에서 해당 원소에 접근하여 작업을 완료한 뒤 Shift를 해줘야 하는 cost가 발생해 O(n)의 시간복잡도를 갖는다.

LinkedList
자료의 주소 값으로 노드를 이용해 서로 연결되어 있는 구조를 갖는다.
삽입과 삭제의 경우 LinkedList가 Array보다 속도가 빠르다고 하지만 엄밀히 말하면 경우에 따라 다르다고 하는게 맞다.
원하는 값을 찾기 위해서 최소 한 번은 리스트를 순회하여야 하므로 O(n)의 시간 복잡도를 갖는다.
트리의 근간이 되는 자료구조이다.
LinkedList 역시 삽입과 삭제를 위해서 해당 노드를 찾아가는 동안 O(n)의 시간 복잡도를 갖는다. 추가적으로 데이터를 삽입 / 삭제하기 위한 시간 복잡도까지 계산하면 결국 O(n)의 시간 복잡도를 갖는 셈이다.

결론
1) 삽입과 삭제가 빈번하다면 LinkedList를 사용하는 것이 더 좋다.
2) 데이터의 접근하는 게 중요하다면 Array를 사용하는 것이 좋다.
https://hongcoding.tistory.com/74